require cve-update-native.inc

FKIE_URL ?= "https://github.com/fkie-cad/nvd-json-data-feeds/releases/latest/download/CVE-"

# Timeout for blocking socket operations, such as the connection attempt.
CVE_SOCKET_TIMEOUT ?= "60"


def db_file_names(d, year):
    year_url = d.getVar('FKIE_URL') + str(year)
    meta_url = year_url + ".meta"
    json_url = year_url + ".json.xz"
    return json_url, meta_url

def update_db_file(db_tmp_file, d, *_):
    """
    Update the given database file
    """
    import bb.progress
    import bb.utils
    import datetime
    from datetime import date
    import lzma
    import sqlite3
    import urllib

    YEAR_START = 2002
    cve_socket_timeout = int(d.getVar("CVE_SOCKET_TIMEOUT"))

    # Connect to database
    conn = sqlite3.connect(db_tmp_file)
    initialize_db(conn)

    with bb.progress.ProgressHandler(d) as ph, open(os.path.join(d.getVar("TMPDIR"), 'cve_check'), 'a') as cve_f:
        pre_update_utc_timestamp = datetime.datetime.now().astimezone(tz=datetime.timezone.utc)
        total_years = date.today().year + 1 - YEAR_START
        for i, year in enumerate(range(YEAR_START, date.today().year + 1)):
            bb.note("Updating %d" % year)
            ph.update((float(i + 1) / total_years) * 100)
            json_url, meta_url = db_file_names(d, year)

            # Retrieve meta last modified date
            try:
                response = urllib.request.urlopen(meta_url, timeout=cve_socket_timeout)
            except urllib.error.URLError as e:
                cve_f.write('Warning: CVE db update error, Unable to fetch CVE data.\n\n')
                bb.warn("Failed to fetch CVE data (%s)" % e)
                import socket
                result = socket.getaddrinfo("github.com", 443, proto=socket.IPPROTO_TCP)
                bb.warn("Host IPs are %s" % (", ".join(t[4][0] for t in result)))
                return False

            if response:
                for line in response.read().decode("utf-8").splitlines():
                    key, value = line.split(":", 1)
                    if key == "lastModifiedDate":
                        last_modified = value
                        break
                else:
                    bb.warn("Cannot parse CVE metadata, update failed")
                    return False

            # Compare with current db last modified date
            cursor = conn.execute("select DATE from META where YEAR = ?", (year,))
            meta = cursor.fetchone()
            cursor.close()

            if not meta or meta[0] != last_modified:
                bb.note("Updating entries")
                # Clear products table entries corresponding to current year
                conn.execute("delete from PRODUCTS where ID like ?", ('CVE-%d%%' % year,)).close()

                # Update db with current year json file
                try:
                    response = urllib.request.urlopen(json_url, timeout=cve_socket_timeout)
                    if response:
                        update_db(conn, lzma.decompress(response.read()))
                    conn.execute("insert or replace into META values (?, ?)", [year, last_modified]).close()
                except urllib.error.URLError as e:
                    cve_f.write('Warning: CVE db update error, CVE data is outdated.\n\n')
                    bb.warn("Cannot parse CVE data (%s), update failed" % e.reason)
                    return False
            else:
                bb.debug(2, "Already up to date (last modified %s)" % last_modified)
            # Update success, set the date to cve_check file.
            if year == date.today().year:
                conn.execute("insert into MTIME values (?)", [pre_update_utc_timestamp.isoformat()]).close()
                cve_f.write('CVE database update : %s\n\n' % date.today())

        conn.commit()
        conn.close()
        return True


def parse_node_and_insert(conn, node, cveId):
    # Parse children node if needed
    for child in node.get('children', ()):
        parse_node_and_insert(conn, child, cveId)

    def cpe_generator():
        match_string = "cpeMatch"
        cpe_string = 'criteria'

        for cpe in node.get(match_string, ()):
            if not cpe['vulnerable']:
                return
            cpe23 = cpe.get(cpe_string)
            if not cpe23:
                return
            cpe23 = cpe23.split(':')
            if len(cpe23) < 6:
                return
            vendor = cpe23[3]
            product = cpe23[4]
            version = cpe23[5]

            if cpe23[6] == '*' or cpe23[6] == '-':
                version_suffix = ""
            else:
                version_suffix = "_" + cpe23[6]

            if version != '*' and version != '-':
                # Version is defined, this is a '=' match
                yield [cveId, vendor, product, version + version_suffix, '=', '', '']
            elif version == '-':
                # no version information is available
                yield [cveId, vendor, product, version, '', '', '']
            else:
                # Parse start version, end version and operators
                op_start = ''
                op_end = ''
                v_start = ''
                v_end = ''

                if 'versionStartIncluding' in cpe:
                    op_start = '>='
                    v_start = cpe['versionStartIncluding']

                if 'versionStartExcluding' in cpe:
                    op_start = '>'
                    v_start = cpe['versionStartExcluding']

                if 'versionEndIncluding' in cpe:
                    op_end = '<='
                    v_end = cpe['versionEndIncluding']

                if 'versionEndExcluding' in cpe:
                    op_end = '<'
                    v_end = cpe['versionEndExcluding']

                if op_start or op_end or v_start or v_end:
                    yield [cveId, vendor, product, v_start, op_start, v_end, op_end]
                else:
                    # This is no version information, expressed differently.
                    # Save processing by representing as -.
                    yield [cveId, vendor, product, '-', '', '', '']

    conn.executemany("insert into PRODUCTS values (?, ?, ?, ?, ?, ?, ?)", cpe_generator()).close()

def get_metric_entry(metric):
    primaries = [c for c in metric if c['type'] == "Primary"]
    secondaries = [c for c in metric if c['type'] == "Secondary"]
    if len(primaries) > 0:
        return primaries[0]
    elif len(secondaries) > 0:
        return secondaries[0]
    return None

def update_db(conn, jsondata):
    import json
    root = json.loads(jsondata)

    for elt in root['cve_items']:
        if 'vulnStatus' not in elt or elt['vulnStatus'] == 'Rejected':
            continue

        if 'configurations' not in elt:
            continue

        accessVector = None
        vectorString = None
        cvssv2 = 0.0
        cvssv3 = 0.0
        cvssv4 = 0.0
        cveId = elt['id']
        cveDesc = elt['descriptions'][0]['value']
        date = elt['lastModified']
        try:
            if 'cvssMetricV2' in elt['metrics']:
                entry = get_metric_entry(elt['metrics']['cvssMetricV2'])
                if entry:
                    accessVector = entry['cvssData']['accessVector']
                    vectorString = entry['cvssData']['vectorString']
                    cvssv2 = entry['cvssData']['baseScore']
        except KeyError:
            cvssv2 = 0.0
        try:
            if 'cvssMetricV30' in elt['metrics']:
                entry = get_metric_entry(elt['metrics']['cvssMetricV30'])
                if entry:
                    accessVector = entry['cvssData']['attackVector']
                    vectorString = entry['cvssData']['vectorString']
                    cvssv3 = entry['cvssData']['baseScore']
        except KeyError:
            accessVector = accessVector or "UNKNOWN"
            cvssv3 = 0.0
        try:
            if 'cvssMetricV31' in elt['metrics']:
                entry = get_metric_entry(elt['metrics']['cvssMetricV31'])
                if entry:
                    accessVector = entry['cvssData']['attackVector']
                    vectorString = entry['cvssData']['vectorString']
                    cvssv3 = entry['cvssData']['baseScore']
        except KeyError:
            accessVector = accessVector or "UNKNOWN"
            cvssv3 = 0.0
        try:
            if 'cvssMetricV40' in elt['metrics']:
                entry = get_metric_entry(elt['metrics']['cvssMetricV40'])
                if entry:
                    accessVector = entry['cvssData']['attackVector']
                    vectorString = entry['cvssData']['vectorString']
                    cvssv4 = entry['cvssData']['baseScore']
        except KeyError:
            accessVector = accessVector or "UNKNOWN"
            cvssv4 = 0.0

        conn.execute("insert or replace into NVD values (?, ?, ?, ?, ?, ?, ?, ?)",
                [cveId, cveDesc, cvssv2, cvssv3, cvssv4, date, accessVector, vectorString]).close()

        for config in elt['configurations']:
            # This is suboptimal as it doesn't handle AND/OR and negate, but is better than nothing
            for node in config.get("nodes") or []:
                parse_node_and_insert(conn, node, cveId)
